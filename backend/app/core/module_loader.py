"""
Module Loader - CORE Service

Ce service est responsable de :
1. D√©couvrir les modules disponibles dans /modules/
2. Valider l'int√©grit√© des modules (manifest, structure, d√©pendances)
3. Charger dynamiquement les mod√®les des modules activ√©s
4. Enregistrer les routes des modules activ√©s
5. Initialiser les hooks, traductions, permissions des modules

Architecture modulaire professionnelle :
- Les modules ne sont JAMAIS import√©s statiquement
- Le CORE d√©couvre et charge les modules au d√©marrage
- Chaque module est isol√© et peut √™tre activ√©/d√©sactiv√©
- Les migrations sont g√©n√©r√©es automatiquement √† partir des mod√®les charg√©s
"""

import importlib
import inspect
import json
import sys
from pathlib import Path
from typing import Any, Dict, List, Optional, Type

from fastapi import APIRouter
from sqlmodel import SQLModel
from sqlalchemy.ext.declarative import DeclarativeMeta

from app.core.models.base import AbstractBaseModel


class ModuleValidationError(Exception):
    """Exception lev√©e lors de la validation d'un module"""
    pass


class ModuleLoader:
    """
    Gestionnaire de chargement dynamique des modules.

    Ce service g√®re le cycle de vie complet des modules :
    - Discovery (d√©couverte des modules disponibles)
    - Validation (int√©grit√©, d√©pendances, conflits)
    - Loading (chargement dynamique des composants)
    - Registration (enregistrement dans le CORE)
    """

    # Chemins de base
    MODULES_DIR = Path("/modules")
    BACKEND_MODULES_DIR = Path("/backend/app/modules")

    # Modules charg√©s (cache)
    _loaded_modules: Dict[str, Dict[str, Any]] = {}
    _loaded_models: List[Type[SQLModel]] = []
    _loaded_routers: List[APIRouter] = []

    @classmethod
    def discover_modules(cls) -> List[Dict[str, Any]]:
        """
        D√©couvre tous les modules disponibles dans /modules/

        Returns:
            Liste des manifests des modules d√©couverts
        """
        modules = []

        if not cls.MODULES_DIR.exists():
            return modules

        for module_dir in cls.MODULES_DIR.iterdir():
            if not module_dir.is_dir():
                continue

            manifest_path = module_dir / "manifest.json"
            if not manifest_path.exists():
                continue

            try:
                with open(manifest_path, 'r', encoding='utf-8') as f:
                    manifest = json.load(f)
                    manifest['_path'] = str(module_dir)
                    modules.append(manifest)
            except Exception as e:
                print(f"Error reading manifest for {module_dir.name}: {e}")
                continue

        return modules

    @classmethod
    def validate_module(cls, manifest: Dict[str, Any]) -> bool:
        """
        Valide l'int√©grit√© d'un module.

        V√©rifie :
        - Structure du manifest
        - Pr√©sence des fichiers requis
        - Validit√© des d√©pendances
        - Absence de conflits

        Args:
            manifest: Manifest du module √† valider

        Returns:
            True si le module est valide

        Raises:
            ModuleValidationError: Si le module est invalide
        """
        module_path = Path(manifest.get('_path', ''))
        module_code = manifest.get('code')

        # 1. V√©rifier les champs obligatoires du manifest
        required_fields = ['name', 'code', 'version']
        for field in required_fields:
            if field not in manifest:
                raise ModuleValidationError(f"Missing required field '{field}' in manifest")

        # 2. V√©rifier la structure des fichiers
        backend_dir = module_path / "backend"
        if backend_dir.exists():
            # Si backend existe, v√©rifier les fichiers requis
            init_file = backend_dir / "__init__.py"
            if not init_file.exists():
                raise ModuleValidationError(f"Missing __init__.py in {backend_dir}")

            # V√©rifier models.py si pr√©sent
            models_file = backend_dir / "models.py"
            if models_file.exists():
                # Valider que models.py est importable
                try:
                    cls._validate_python_file(models_file)
                except Exception as e:
                    raise ModuleValidationError(f"Invalid models.py: {e}")

            # V√©rifier routes.py si pr√©sent
            routes_file = backend_dir / "routes.py"
            if routes_file.exists():
                try:
                    cls._validate_python_file(routes_file)
                except Exception as e:
                    raise ModuleValidationError(f"Invalid routes.py: {e}")

        # 3. V√©rifier les d√©pendances
        dependencies = manifest.get('dependencies', {})

        # D√©pendances services CORE
        core_services = dependencies.get('core_services', [])
        # TODO: V√©rifier que les services CORE requis sont disponibles

        # D√©pendances autres modules
        required_modules = dependencies.get('modules', [])
        for req_module in required_modules:
            req_code = req_module.get('code')
            # TODO: V√©rifier que le module requis est install√© et activ√©

        # 4. V√©rifier les conflits de noms (permissions, menus, hooks)
        # TODO: V√©rifier qu'aucune permission/menu/hook ne conflicte avec l'existant

        return True

    @classmethod
    def _validate_python_file(cls, file_path: Path):
        """Valide qu'un fichier Python est syntaxiquement correct"""
        with open(file_path, 'r', encoding='utf-8') as f:
            code = f.read()
            compile(code, str(file_path), 'exec')

    @classmethod
    def load_module_models(cls, module_code: str) -> List[Type[SQLModel]]:
        """
        Charge dynamiquement les mod√®les d'un module.

        Args:
            module_code: Code du module (ex: 'hse')

        Returns:
            Liste des classes de mod√®les charg√©es
        """
        models = []

        # Construire le chemin du module
        backend_module_path = cls.BACKEND_MODULES_DIR / module_code
        models_file = backend_module_path / "models.py"

        if not models_file.exists():
            return models

        # Importer dynamiquement le module
        module_name = f"app.modules.{module_code}.models"

        try:
            # Importer le module
            if module_name in sys.modules:
                # Recharger si d√©j√† import√©
                module = importlib.reload(sys.modules[module_name])
            else:
                module = importlib.import_module(module_name)

            # Extraire toutes les classes qui h√©ritent de SQLModel et ont table=True
            for name, obj in inspect.getmembers(module, inspect.isclass):
                # V√©rifier que c'est une table SQLModel (pas un schema Pydantic)
                if (hasattr(obj, '__tablename__') and
                    issubclass(obj, SQLModel) and
                    obj is not SQLModel and
                    obj is not AbstractBaseModel):
                    models.append(obj)
                    print(f"  ‚úì Loaded model: {name} (table: {obj.__tablename__})")

        except Exception as e:
            print(f"  ‚úó Error loading models from {module_code}: {e}")
            raise

        return models

    @classmethod
    def load_module_router(cls, module_code: str) -> Optional[APIRouter]:
        """
        Charge dynamiquement le router d'un module.

        Args:
            module_code: Code du module (ex: 'hse')

        Returns:
            APIRouter du module ou None
        """
        # Construire le chemin du module
        backend_module_path = cls.BACKEND_MODULES_DIR / module_code
        routes_file = backend_module_path / "routes.py"

        if not routes_file.exists():
            return None

        # Importer dynamiquement le module
        module_name = f"app.modules.{module_code}.routes"

        try:
            # Importer le module
            if module_name in sys.modules:
                module = importlib.reload(sys.modules[module_name])
            else:
                module = importlib.import_module(module_name)

            # Chercher l'objet 'router'
            if hasattr(module, 'router'):
                router = getattr(module, 'router')
                if isinstance(router, APIRouter):
                    print(f"  ‚úì Loaded router: {module_code} (prefix: {router.prefix})")
                    return router

            print(f"  ‚ö† No router found in {module_code}.routes")
            return None

        except Exception as e:
            print(f"  ‚úó Error loading router from {module_code}: {e}")
            raise

    @classmethod
    def load_active_modules(cls, session) -> Dict[str, Any]:
        """
        Charge tous les modules activ√©s dans la base de donn√©es.

        Cette m√©thode est appel√©e au d√©marrage de l'application.

        Args:
            session: Session SQLModel pour acc√©der √† la DB

        Returns:
            Dictionnaire des modules charg√©s avec leurs composants
        """
        from app.services.module_service import ModuleManager

        loaded = {
            'models': [],
            'routers': [],
            'modules': []
        }

        print("\n" + "="*60)
        print("üîå MODULE LOADER - Chargement des modules activ√©s")
        print("="*60)

        # R√©cup√©rer les modules activ√©s depuis la DB
        active_modules = ModuleManager.get_active_modules(session)

        if not active_modules:
            print("‚ÑπÔ∏è  Aucun module activ√©")
            return loaded

        print(f"\nüì¶ {len(active_modules)} module(s) activ√©(s) trouv√©(s)\n")

        for module in active_modules:
            module_code = module.code
            print(f"  ‚Üí Chargement du module '{module_code}' v{module.version}")

            try:
                # Charger les mod√®les
                models = cls.load_module_models(module_code)
                loaded['models'].extend(models)
                cls._loaded_models.extend(models)

                # Charger le router
                router = cls.load_module_router(module_code)
                if router:
                    loaded['routers'].append(router)
                    cls._loaded_routers.append(router)

                loaded['modules'].append({
                    'code': module_code,
                    'name': module.name,
                    'version': module.version
                })

                print(f"  ‚úÖ Module '{module_code}' charg√© avec succ√®s\n")

            except Exception as e:
                print(f"  ‚ùå Erreur lors du chargement de '{module_code}': {e}\n")
                # Ne pas arr√™ter le chargement des autres modules
                continue

        print("="*60)
        print(f"‚úÖ Chargement termin√©: {len(loaded['modules'])} modules charg√©s")
        print(f"   - {len(loaded['models'])} mod√®les")
        print(f"   - {len(loaded['routers'])} routers")
        print("="*60 + "\n")

        return loaded

    @classmethod
    def get_loaded_models(cls) -> List[Type[SQLModel]]:
        """Retourne la liste des mod√®les charg√©s"""
        return cls._loaded_models

    @classmethod
    def get_loaded_routers(cls) -> List[APIRouter]:
        """Retourne la liste des routers charg√©s"""
        return cls._loaded_routers

    @classmethod
    def register_module_routers(cls, app):
        """
        Enregistre tous les routers des modules charg√©s dans l'app FastAPI.

        Args:
            app: Instance FastAPI
        """
        for router in cls._loaded_routers:
            app.include_router(router)
            print(f"  ‚úì Router registered: {router.prefix}")
